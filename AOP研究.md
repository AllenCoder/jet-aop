预研目的


Aop编程是一种区别OOP编程的概念，从切面的角度看待问题，这篇文章主要讲述了Java开发中常用的Aop开发方式以及他们的优缺点和区别。



什么是Aop编程

AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。
AOP是OOP的延续，是软件开发中的一个热点，也是spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 



常见的使用场景

性能监控: 在方法调用前后记录调用时间，方法执行太长或超时报警。

缓存代理: 缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。

软件破解: 使用AOP修改软件的验证类的判断逻辑。

记录日志: 在方法执行前后记录系统日志。

工作流系统: 工作流系统需要将业务代码和流程引擎代码混合在一起执行，那么我们可以使用AOP将其分离，并动态挂接业务。

权限验证: 方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，由业务代码捕捉。
如果对Aop的概念不理解，可以参考文章Aop那些事 



JAVA中Aop的具体实现方式

1、JDK动态代理

有过java开发经验的朋友都知道，java通过实现InvocationHandler接口，可以实现对一个类的动态代理，通过动态代理，我们可以生成代理类从而在代理类方法中，在执行被代理类方法前后，添加自己的实现内容，从而实现Aop。

优点：动态代理java自身支持，不需要引入外部库，在运行期通过接口动态生成代理类

缺点：首先代理类必须实现一个接口，如果没实现接口会抛出一个异常。第二性能影响，因为动态代理使用反射的机制实现的，首先反射肯定比直接调用要慢



2、动态字节码生成

在运行期，目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中，没有接口也可以织入，但扩展类的实例方法为final时，则无法进行织入。

可以使用Cglib来实现动态字节码生成，这是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。

优点：可以织入没有接口的类；运行时生成，减少不必要的生成开销；通过字节码生成子类，而不是反射方式去调用代理类

缺点：不能织入final方法；运行时生成子类，说明会有生成开销，并且可能生成大量子类



3、自定义类加载器

在运行期，目标加载前，将切面逻辑加到目标字节码里。

可以对绝大部分类进行织入，但代码中如果使用了其他类加载器，则这些类将不会被织入。

Javassist是一个编辑字节码的框架，可以让你很简单地操作字节码。它可以在运行期定义或修改Class。使用Javassist实现AOP的原理是在字节码加载前直接修改需要切入的方法。这比使用Cglib实现AOP更加高效，并且没太多限制.

优点：可以织入绝大部分类；运行时生成，减少不必要的生成开销；通过将切面逻辑写入字节码，减少了生成子类的开销，不会产生过多子类

缺点：运行时加入切面逻辑，产生开销；



4、ASM

ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。

从上面的描述可以看出，ASM可以在编译期直接修改编译出的字节码文件，也可以像javassit一样，在运行期，类文件加载前，去修改字节码。两者的区别在于，一个将所有需要AOP的类都事先修改了，一个在运行时需要才去修改。

优点：可以织入绝所有类；两者生成方式，可以根据需求选择

缺点：修改字节码，需要对class文件比较熟悉，编写过程复杂



5、AspectJ

AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。
和ASM一样，Aspectj有静态编译和动态编译的优点，供程序员选择。另外Aspectj其编码更为简洁，是Android开发中，实现AOP的首选。

优点：可以织入绝所有类；两者生成方式，可以根据需求选择；编写简单，功能强大

缺点：需要使用ajc编译器编译，ajc编译器是java编译器的扩展，具有其所有功能



6、APT

自定义一个AbstractProcessor，在编译期去解析编译的类，并且根据需求生成一个实现了特定接口的子类(代理类)，和JDK动态代理不同的是，代理类是在编译期生成的。常见的一些Android的IOC框架中有大量应用(就是通过注解代替findviewbyid等方法)。 
详情可以参考 Android 打造编译时注解解析框架 这只是一个开始

这里顺便说一句，目前Android注解解析框架主要有两种实现方法，一种是运行期通过反射去解析当前类，注入相应要运行的方法，一种是在编译期生成类的代理类，在运行期直接调用代理类的代理方法。APT指的是后者。

这两种实现方式，后者消耗更少，但是会生成大量代理类。

优点：可以织入绝所有类；编译期代理，减少运行时消耗

缺点：需要使用apt编译器编译；需要手动拼接代理的代码(其实是整个字符串)；生成大量代理类


写在最后

JAVA中AOP有多种实现方式，各有优缺点，在实际项目中，我选择了AspectJ，因为它的动静结合和编写简单，网上也有不少使用AspectJ来实现Android AOP的框架，例如https://github.com/JakeWharton/hugo。